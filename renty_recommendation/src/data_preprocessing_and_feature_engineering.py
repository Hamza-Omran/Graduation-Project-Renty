# -*- coding: utf-8 -*-
"""DATA_PREPROCESSING_and_FEATURE_ENGINEERING

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sqnl4IZbyQn8S-K0r4ltkBzuxfUkAfw8

## DATA PREPROCESSING
"""

def load_and_preprocess_data(filepath):
    """Load and perform initial preprocessing on the dataset"""
    print("=" * 80)
    print("STEP 1: DATA PREPROCESSING")
    print("=" * 80)

    df = pd.read_excel(filepath)

    # Convert date columns
    df['OrderDate'] = pd.to_datetime(df['OrderDate'])
    df['StockDate'] = pd.to_datetime(df['StockDate'])

    # Remove duplicates if any
    df = df.drop_duplicates()

    print(f"Dataset shape: {df.shape}")
    print(f"Number of unique users: {df['CustomerKey'].nunique()}")
    print(f"Number of unique items: {df['ProductKey'].nunique()}")
    print(f"Sparsity: {1 - len(df) / (df['CustomerKey'].nunique() * df['ProductKey'].nunique()):.4f}")

    return df

"""##  ADVANCED FEATURE ENGINEERING"""

def engineer_features(df):
    """Create advanced features with scaling and text encoding"""
    print("\n" + "=" * 80)
    print("STEP 2: ADVANCED FEATURE ENGINEERING")
    print("=" * 80)

    df_features = df.copy()

    # ===== TEMPORAL FEATURES =====
    df_features['OrderYear'] = df_features['OrderDate'].dt.year
    df_features['OrderMonth'] = df_features['OrderDate'].dt.month
    df_features['OrderQuarter'] = df_features['OrderDate'].dt.quarter
    df_features['DayOfWeek'] = df_features['OrderDate'].dt.dayofweek
    df_features['IsWeekend'] = df_features['DayOfWeek'].isin([5, 6]).astype(int)

    # Seasonality
    df_features['Season'] = df_features['OrderMonth'].map({
        12: 'Winter', 1: 'Winter', 2: 'Winter',
        3: 'Spring', 4: 'Spring', 5: 'Spring',
        6: 'Summer', 7: 'Summer', 8: 'Summer',
        9: 'Fall', 10: 'Fall', 11: 'Fall'
    })

    # ===== IMPROVED CATEGORICAL FEATURES =====
    # Fine-grained income brackets
    df_features['IncomeBracket'] = pd.cut(df_features['AnnualIncome'],
                                           bins=[0, 25000, 40000, 60000, 80000, 100000, 200000],
                                           labels=['VeryLow', 'Low', 'Medium', 'High', 'VeryHigh', 'Premium'])

    # Children category
    df_features['ChildrenCategory'] = pd.cut(df_features['TotalChildren'],
                                              bins=[-1, 0, 1, 2, 10],
                                              labels=['NoChildren', 'OneChild', 'TwoChildren', 'ManyChildren'])

    # ===== USER ENGAGEMENT METRICS =====
    user_stats = df_features.groupby('CustomerKey').agg({
        'OrderNumber': 'nunique',
        'ProductKey': 'nunique',
        'OrderQuantity': ['sum', 'mean', 'std'],
        'OrderDate': lambda x: (x.max() - x.min()).days,
        'AnnualIncome': 'first'
    }).reset_index()

    user_stats.columns = ['CustomerKey', 'TotalOrders', 'UniqueProducts',
                          'TotalQuantity', 'AvgOrderQuantity', 'StdOrderQuantity',
                          'CustomerLifetimeDays', 'AnnualIncome']

    # Replace NaN std with 0 for single-order customers
    user_stats['StdOrderQuantity'] = user_stats['StdOrderQuantity'].fillna(0)

    # Customer Value Score (RFM-inspired)
    user_stats['CustomerValueScore'] = (
        user_stats['TotalOrders'] * 0.3 +
        user_stats['UniqueProducts'] * 0.3 +
        (user_stats['TotalQuantity'] / user_stats['TotalQuantity'].max()) * 100 * 0.4
    )

    # Customer segments
    user_stats['CustomerSegment'] = pd.qcut(user_stats['CustomerValueScore'],
                                             q=4, labels=['Bronze', 'Silver', 'Gold', 'Platinum'],
                                             duplicates='drop')

    # Merge user stats back
    df_features = df_features.merge(user_stats[['CustomerKey', 'TotalOrders', 'UniqueProducts',
                                                 'TotalQuantity', 'AvgOrderQuantity', 'StdOrderQuantity',
                                                 'CustomerLifetimeDays', 'CustomerValueScore', 'CustomerSegment']],
                                    on='CustomerKey', how='left')

    # ===== ITEM FEATURES =====
    item_stats = df_features.groupby('ProductKey').agg({
        'OrderQuantity': ['sum', 'mean', 'count'],
        'CustomerKey': 'nunique',
        'ModelName': 'first',
        'ProductDescription': 'first'
    }).reset_index()

    item_stats.columns = ['ProductKey', 'TotalItemsSold', 'AvgItemOrderQty',
                          'ItemPopularity', 'UniqueCustomers', 'ModelName', 'ProductDescription']

    # Item category from ModelName
    item_stats['ItemCategory'] = item_stats['ModelName'].apply(lambda x: x.split('-')[0] if '-' in str(x) else 'Other')

    # Popularity percentile
    item_stats['PopularityPercentile'] = pd.qcut(item_stats['ItemPopularity'],
                                                   q=5, labels=['Niche', 'LowPop', 'MedPop', 'HighPop', 'Viral'],
                                                   duplicates='drop')

    df_features = df_features.merge(item_stats[['ProductKey', 'TotalItemsSold', 'AvgItemOrderQty',
                                                 'ItemPopularity', 'UniqueCustomers', 'ItemCategory',
                                                 'PopularityPercentile']],
                                    on='ProductKey', how='left')

    # ===== SCALED NUMERICAL FEATURES =====
    print("\nApplying feature scaling...")
    scaler = MinMaxScaler()

    numerical_cols = ['AnnualIncome', 'TotalChildren', 'TotalOrders', 'UniqueProducts',
                      'AvgOrderQuantity', 'CustomerLifetimeDays', 'CustomerValueScore']

    for col in numerical_cols:
        if col in df_features.columns:
            df_features[f'{col}_Scaled'] = scaler.fit_transform(df_features[[col]])

    print("\nEngineered features:")
    print(f"  ✓ Temporal: OrderYear, OrderMonth, OrderQuarter, DayOfWeek, IsWeekend, Season")
    print(f"  ✓ User Demographics: IncomeBracket (6 levels), ChildrenCategory (4 levels)")
    print(f"  ✓ User Engagement: TotalOrders, UniqueProducts, AvgOrderQuantity, StdOrderQuantity")
    print(f"  ✓ User Segmentation: CustomerValueScore, CustomerSegment (Bronze/Silver/Gold/Platinum)")
    print(f"  ✓ Item Features: ItemCategory, PopularityPercentile, UniqueCustomers")
    print(f"  ✓ Scaled Features: {len(numerical_cols)} numerical features normalized")

    return df_features